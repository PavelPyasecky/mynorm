name: Deploy to Stage

on:
  push:
    branches:
      - stage
  workflow_dispatch:

env:
  DEPLOY_PATH: /root/mynorm
  DOCKER_COMPOSE_FILE: docker-compose.stage.yml

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read and increment version
        id: version
        run: |
          if [ -f VERSION ]; then
            CURRENT_VERSION=$(cat VERSION | tr -d ' \n\r')
            echo "Current version: $CURRENT_VERSION"
            
            # Parse semantic version (MAJOR.MINOR.PATCH)
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            # Increment patch version
            PATCH=$((PATCH + 1))
            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
            
            echo "$NEW_VERSION" > VERSION
            echo "New version: $NEW_VERSION"
            
            echo "semantic_version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "üì¶ Version: $NEW_VERSION"
          else
            echo "semantic_version=0.0.0" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  VERSION file not found"
          fi

      - name: Commit updated VERSION file
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git add VERSION
          if git diff --staged --quiet; then
            echo "No changes to VERSION file"
          else
            git commit -m "chore: bump version to ${{ steps.version.outputs.semantic_version }} [skip ci]"
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
            git push origin HEAD:$BRANCH_NAME || echo "‚ö†Ô∏è  Failed to push VERSION update"
          fi

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Validate required secrets
          if [ -z "${{ secrets.STAGE_VPS_HOST }}" ]; then
            echo "‚ùå STAGE_VPS_HOST is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.STAGE_VPS_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå STAGE_VPS_SSH_PRIVATE_KEY is not set"
            exit 1
          fi
          
          # Write SSH private key
          echo "${{ secrets.STAGE_VPS_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Add host to known_hosts (suppress errors if host is unreachable during scan)
          echo "üìù Adding VPS host to known_hosts..."
          ssh-keyscan -H "${{ secrets.STAGE_VPS_HOST }}" >> ~/.ssh/known_hosts 2>&1 || {
            echo "‚ö†Ô∏è  Warning: Could not scan host keys (this is OK if VPS is ready)"
            # Create empty known_hosts if it doesn't exist
            touch ~/.ssh/known_hosts
          }
          
          # Verify SSH key exists
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå SSH private key file not created"
            exit 1
          fi
          
          echo "‚úÖ SSH configured on GitHub Actions runner"
          echo "‚ÑπÔ∏è  Note: VPS should already have the public key in ~/.ssh/authorized_keys"

      - name: Pull code and deploy on VPS
        run: |
          ssh ${{ secrets.STAGE_VPS_USER }}@${{ secrets.STAGE_VPS_HOST }} << EOF
            set -e
            cd ${{ env.DEPLOY_PATH }}
            
            BRANCH_NAME="${{ github.ref_name }}"
            echo "üì• Pulling latest code from \$BRANCH_NAME branch..."
            git fetch origin
            git checkout \$BRANCH_NAME
            git pull origin \$BRANCH_NAME
            
            echo "üî® Building Docker containers..."
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache
            
            echo "üõë Stopping existing containers..."
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down
            
            echo "üöÄ Starting containers..."
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d
            
            echo "‚è≥ Waiting for services to start..."
            sleep 30
            
            echo "üîç Checking service status..."
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
            
            echo "üìã Checking Django logs..."
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} logs django --tail=20
          EOF

      - name: Health check
        run: |
          ssh ${{ secrets.STAGE_VPS_USER }}@${{ secrets.STAGE_VPS_HOST }} << 'EOF'
            set -e
            cd ${{ env.DEPLOY_PATH }}
            
            echo "üß™ Running health checks..."
            
            # Check if Django is responding
            if docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T django python manage.py check --deploy; then
              echo "‚úÖ Django health check passed"
            else
              echo "‚ùå Django health check failed"
              exit 1
            fi
            
            # Test API endpoints
            API_URL="${{ secrets.STAGE_API_URL }}"
            if [ -z "$API_URL" ]; then
              API_URL="https://dev-314.ru"
            fi
            if curl -f -I ${API_URL}/api/health/; then
              echo "‚úÖ API health endpoint check passed"
            else
              echo "‚ùå API health endpoint check failed"
              exit 1
            fi
            
            # Check if drf_spectacular is installed
            if docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T django python -c "import drf_spectacular; print('‚úÖ drf_spectacular installed')"; then
              echo "‚úÖ drf_spectacular check passed"
            else
              echo "‚ùå drf_spectacular check failed"
              exit 1
            fi
          EOF

      - name: Cleanup old images
        if: always()
        run: |
          ssh ${{ secrets.STAGE_VPS_USER }}@${{ secrets.STAGE_VPS_HOST }} << 'EOF'
            echo "üßπ Cleaning up old Docker images..."
            docker image prune -f
          EOF

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Stage deployment successful!"
          else
            echo "‚ùå Stage deployment failed!"
          fi
